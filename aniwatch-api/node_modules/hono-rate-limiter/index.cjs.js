"use strict";var e=require("hono/factory");const t=(e,t)=>{let i;if(e){const t=Math.ceil((e.getTime()-Date.now())/1e3);i=Math.max(0,t)}else t&&(i=Math.ceil(t/1e3));return i};class i{init(e){this.windowMs=e.windowMs,this.interval&&clearInterval(this.interval),this.interval=setInterval((()=>{this.clearExpired()}),this.windowMs),this.interval.unref&&this.interval.unref()}async get(e){return this.current.get(e)??this.previous.get(e)}async increment(e){const t=this.getClient(e),i=Date.now();return t.resetTime.getTime()<=i&&this.resetClient(t,i),t.totalHits++,t}async decrement(e){const t=this.getClient(e);t.totalHits>0&&t.totalHits--}async resetKey(e){this.current.delete(e),this.previous.delete(e)}async resetAll(){this.current.clear(),this.previous.clear()}shutdown(){clearInterval(this.interval),this.resetAll()}resetClient(e,t=Date.now()){return e.totalHits=0,e.resetTime.setTime(t+this.windowMs),e}getClient(e){const t=this.current.get(e);if(t)return t;let i;const s=this.previous.get(e);return s?(i=s,this.previous.delete(e)):(i={totalHits:0,resetTime:new Date},this.resetClient(i)),this.current.set(e,i),i}clearExpired(){this.previous=this.current,this.current=new Map}constructor(){this.previous=new Map,this.current=new Map,this.localKeys=!0}}const s=e=>!!e?.increment;function r(e,t){if(!s(e))throw new Error("The store is not correctly implemented!");"function"==typeof e.init&&e.init(t)}async function a(e,t,i){const s=await t(e),{totalHits:r,resetTime:a}=await i.increment(s);return{key:s,totalHits:r,resetTime:a}}exports.rateLimiter=function(s){const{windowMs:n=6e4,limit:o=5,message:c="Too many requests, please try again later.",statusCode:l=429,standardHeaders:u="draft-6",requestPropertyName:m="rateLimit",requestStorePropertyName:d="rateLimitStore",skipFailedRequests:w=!1,skipSuccessfulRequests:y=!1,keyGenerator:h,skip:f=(()=>!1),requestWasSuccessful:p=(e=>e.res.status<400),handler:g=(async(e,t,i)=>{e.status(i.statusCode);const s="function"==typeof i.message?await i.message(e):i.message;return"string"==typeof s?e.text(s):e.json(s)}),store:M=new i}=s,q={windowMs:n,limit:o,message:c,statusCode:l,standardHeaders:u,requestPropertyName:m,requestStorePropertyName:d,skipFailedRequests:w,skipSuccessfulRequests:y,keyGenerator:h,skip:f,requestWasSuccessful:p,handler:g,store:M};return r(M,q),e.createMiddleware((async(e,i)=>{if(await f(e))return void await i();const{key:s,totalHits:r,resetTime:c}=await a(e,h,M),l="function"==typeof o?o(e):o,k=await l,v={limit:k,used:r,remaining:Math.max(k-r,0),resetTime:c};e.set(m,v),e.set(d,{getKey:M.get?.bind(M),resetKey:M.resetKey.bind(M)}),u&&!e.finalized&&("draft-7"===u?((e,i,s)=>{if(e.finalized)return;const r=Math.ceil(s/1e3),a=t(i.resetTime,s);e.header("RateLimit-Policy",`${i.limit};w=${r}`),e.header("RateLimit",`limit=${i.limit}, remaining=${i.remaining}, reset=${a}`)})(e,v,n):((e,i,s)=>{if(e.finalized)return;const r=Math.ceil(s/1e3),a=t(i.resetTime);e.header("RateLimit-Policy",`${i.limit};w=${r}`),e.header("RateLimit-Limit",i.limit.toString()),e.header("RateLimit-Remaining",i.remaining.toString()),a&&e.header("RateLimit-Reset",a.toString())})(e,v,n));let T=!1;const R=async()=>{T||(await M.decrement(s),T=!0)},S=async()=>{if(w||y){const t=await p(e);(w&&!t||y&&t)&&await R()}};if(r>k)return u&&((e,i,s)=>{if(e.finalized)return;const r=t(i.resetTime,s);e.header("Retry-After",r?.toString())})(e,v,n),await S(),g(e,i,q);try{await i(),await S()}catch(e){w&&await R()}finally{e.finalized||await R()}}))},exports.webSocketLimiter=function(e){const{windowMs:t=6e4,limit:s=5,message:n="Too many requests, please try again later.",statusCode:o=1008,requestPropertyName:c="rateLimit",requestStorePropertyName:l="rateLimitStore",skipFailedRequests:u=!1,skipSuccessfulRequests:m=!1,keyGenerator:d,skip:w=(()=>!1),handler:y=(async(e,t,i)=>t.close(i.statusCode,i.message)),store:h=new i}=e,f={windowMs:t,limit:s,message:n,statusCode:o,requestPropertyName:c,requestStorePropertyName:l,skipFailedRequests:u,skipSuccessfulRequests:m,keyGenerator:d,skip:w,handler:y,store:h};return r(h,f),e=>async t=>{const i=await e(t);return{...i,onMessage:async(e,r)=>{if(await w(e,r))return void await(i.onMessage?.(e,r));const{key:n,totalHits:o,resetTime:p}=await a(t,d,h),g="function"==typeof s?s(t):s,M=await g,q={limit:M,used:o,remaining:Math.max(M-o,0),resetTime:p};t.set(c,q),t.set(l,{getKey:h.get?.bind(h),resetKey:h.resetKey.bind(h)});let k=!1;const v=async()=>{k||(await h.decrement(n),k=!0)},T=async()=>{m&&await v()};if(o>M)return await T(),y(e,r,f);try{await(i.onMessage?.(e,r)),await T()}catch(e){u&&await v()}},onError:async(e,s)=>{if(u){const e=await d(t);await h.decrement(e)}i.onError?.(e,s)}}}};
